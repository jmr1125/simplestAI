#include "train.h"
#include <iostream>
using std::cout;
using std::endl;
void train(network &net, string s, int expect) {
  matrix tmp;
  tmp.setm(1);
  assert(s.size() == 256);
  tmp.setn(256);
  for (int i = 0; i < 256; ++i) {
    tmp(i, 0) = s[i] - '0';
  }
  // cout<<tmp<<endl;
  net.setInput(tmp.getvec());
  net.getV();
  // cout << net.getVdVi(i) << endl;
  // net.getVdbi(i);
  valT delta = 0;
  for (int i = 0; i < net.output.size(); ++i) {
    if (expect != i) {
      delta += net.output[i] * net.output[i];
    } else {
      delta += (1 - net.output[i]) * (1 - net.output[i]);
    }
  }
  // for (int l = 0; l < net.layers.size(); ++l) {
  //   cout << l << " -> " << endl;
  //   cout << "w:" << net.layers[l].w << endl;
  //   cout << "b:" << net.layers[l].b << endl;
  // }
  // {
  //   const auto &output = net.output;
  //   cout << "output: [" << endl;
  //   for (const auto &x : output) {
  //     cout << "[";
  //     cout << x << " ";
  //     cout << "]" << endl;
  //   }
  // }
  cout << "delta:\t" << std::fixed << delta << "\ttime:\t"
       << clock() / CLOCKS_PER_SEC;
  {
    const auto &output = net.output;
    cout << "\toutput:\t";
    for (const auto &x : output) {
      cout << x << "\t";
    }
  }
  cout << endl;
  // delta d? = delta dv v d? = 2(delta-v)*vd?
  // modify it
  vector<matrix> netVw;
  vector<matrix> netVb;
  netVw.reserve(net.layers.size());
  netVb.reserve(net.layers.size());
  for (int i = 0; i < net.layers.size(); ++i) {
    netVw[i] = net.layers[i].w;
    netVb[i] = net.layers[i].b;
  }
#pragma omp parallel for
  for (int i = 0; i < net.output.size(); ++i) {
    valT v = (net.output[i] - (i == expect ? 1 : 0)) *
             2; //(V_i-e)^2 d? = 2(V_i-e)*V_i d ?
    v /= 10000;
    for (int l = 0; l < net.layers.size(); ++l) {
      const matrix &&vdb = net.getVdbi(l);
      const valT delta_b = vdb(i, 0) * v;
      netVb[l](i, 0) -= delta_b;
      for (int j = 0; j < net.layers[l].w.getm(); ++j) {
        const matrix &&vdw = net.getVdWij(l, j);
        const valT delta_w = vdw(i, 0) * v;
        netVw[l](i, j) -= delta_w;
      }
    }
  }
  for (int i = 0; i < net.layers.size(); ++i) {
    net.layers[i].w = netVw[i];
    net.layers[i].b = netVb[i];
  }

  // for (int i = 0; i < net.layers.size(); ++i) {
  //   auto &b = net.layers[i].b;
  //   valT v = 2 * delta;
  //   const matrix &&vdb = net.getVdbi(i);
  //   assert(vdb.getm() == 1);
  //   // assert(vdb.getn() == b.getn());
  //   // assert(vdb.getn() == net.output.size());
  //   for (int j = 0; j < net.output.size(); ++j) {
  //     b(j, 0) -= v * vdb(j, 0);
  //   }
  //   auto &w = net.layers[i].w;
  //   for (int j = 0; j < w.getm(); ++j) {
  //     const matrix &&vdw = net.getVdWij(i, j);
  //     for (int k = 0; j < w.getn(); ++j) {
  //       w(k, j) -= v * vdw(k, 0);
  //     }
  //   }
  // }
}
